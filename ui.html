<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Figma Time Tracker</title>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #fff;
      color: #333;
    }
    
    .container {
      padding: 16px;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 16px;
    }
    
    .tab-button {
      padding: 8px 16px;
      border: none;
      background: none;
      cursor: pointer;
      font-weight: 500;
      color: #666;
    }
    
    .tab-button.active {
      color: #000;
      border-bottom: 2px solid #000;
    }
    
    .tab-content {
      display: none;
      margin-top: 16px;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Timer */
    .timer-section {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .timer-display {
      font-size: 36px;
      font-weight: bold;
      margin: 16px 0;
      position: relative;
      display: inline-block;
    }
    
    #timer-dot {
      position: absolute;
      top: 0;
      right: -12px;
      width: 8px;
      height: 8px;
      background-color: #ff3b30;
      border-radius: 50%;
      display: none;
    }
    
    .file-info {
      margin-bottom: 16px;
      text-align: center;
    }
    
    #file-name {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 4px;
    }
    
    #page-name {
      color: #666;
      font-size: 14px;
    }
    
    /* Buttons */
    .control-buttons {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-bottom: 24px;
    }
    
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    
    #start-button {
      background-color: #34c759;
      color: white;
    }
    
    #stop-button {
      background-color: #ff3b30;
      color: white;
      display: none;
    }
    
    /* Settings */
    .settings-section {
      margin-bottom: 24px;
    }
    
    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #eee;
    }
    
    .setting-label {
      font-weight: 500;
    }
    
    /* Files list */
    .files-list {
      margin-top: 24px;
    }
    
    .file-item {
      padding: 12px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }
    
    .file-item-name {
      font-weight: 500;
    }
    
    .file-item-time {
      color: #666;
    }
    
    /* Summary tab */
    #summary-tab {
      position: relative;
    }
    
    #summary-loading {
      text-align: center;
      margin: 20px 0;
      color: #666;
      font-style: italic;
    }
    
    .summary-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    
    .summary-title {
      font-size: 18px;
      font-weight: bold;
    }
    
    .summary-refresh button {
      background-color: #007aff;
      color: white;
      padding: 6px 12px;
      font-size: 12px;
    }
    
    .summary-list {
      margin-bottom: 24px;
    }
    
    .summary-file-entry {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .summary-file-name {
      font-weight: 500;
    }
    
    .summary-file-time {
      font-family: monospace;
    }
    
    .summary-total {
      display: flex;
      justify-content: space-between;
      padding: 16px 0;
      border-top: 2px solid #ddd;
      margin-top: 8px;
    }
    
    .summary-total-label {
      font-weight: bold;
    }
    
    .summary-total-time {
      font-family: monospace;
      font-weight: bold;
    }
    
    .no-data {
      text-align: center;
      color: #666;
      margin: 40px 0;
    }
    
    .error {
      color: #ff3b30;
      text-align: center;
      margin: 20px 0;
    }
    
    .summary-retry-button, .summary-refresh-button {
      display: block;
      margin: 16px auto;
      background-color: #007aff;
      color: white;
    }
    
    /* Firebase status */
    #firebase-status {
      text-align: center;
      font-size: 12px;
      margin-top: 20px;
      min-height: 16px;
    }
    
    /* Toggle switch */
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
    }
    
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: #2196F3;
    }
    
    input:checked + .slider:before {
      transform: translateX(20px);
    }

    /* Error message */
    .error-message {
      background-color: #fff8f8;
      border-left: 4px solid #ff3b30;
      color: #333;
      padding: 12px;
      margin: 16px 0;
      font-size: 13px;
      line-height: 1.4;
    }
    
    .warning-message {
      background-color: #fffbf0;
      border-left: 4px solid #ffcc00;
      color: #333;
      padding: 12px;
      margin: 16px 0;
      font-size: 13px;
      line-height: 1.4;
    }
    
    .message-title {
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    .message-action {
      margin-top: 8px;
    }
    
    .message-action button {
      background-color: #f5f5f5;
      color: #333;
      border: 1px solid #ddd;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-left: 8px;
    }
    
    .status-indicator.good {
      background-color: #34c759;
    }
    
    .status-indicator.warning {
      background-color: #ffcc00;
    }
    
    .status-indicator.error {
      background-color: #ff3b30;
    }
    
    .storage-status-container {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid #eee;
    }
    
    #storage-info {
      margin-top: 8px;
      margin-bottom: 16px;
      font-size: 12px;
      color: #666;
    }
    
    #storage-actions {
      margin-top: 12px;
    }
    
    .danger-button {
      background-color: #ff3b30;
      color: white;
      font-size: 12px;
      padding: 6px 12px;
    }
    
    .firebase-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-left: 6px;
    }
    
    .firebase-indicator.connected {
      background-color: #34c759;
    }
    
    .firebase-indicator.connecting {
      background-color: #ffcc00;
      animation: pulse 1.5s infinite;
    }
    
    .firebase-indicator.disconnected {
      background-color: #ff3b30;
    }
    
    @keyframes pulse {
      0% { opacity: 0.3; }
      50% { opacity: 1; }
      100% { opacity: 0.3; }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Tabs -->
    <div class="tabs">
      <button class="tab-button active" data-tab="tracking-tab">Tracking</button>
      <button class="tab-button" data-tab="summary-tab">Summary</button>
      <button class="tab-button" data-tab="settings-tab">Settings</button>
    </div>
    
    <!-- Tracking Tab -->
    <div id="tracking-tab" class="tab-content active">
      <!-- Timer Display -->
      <div class="timer-section">
        <div class="timer-display">
          <span id="timer">00:00:00</span>
          <div id="timer-dot"></div>
        </div>
        <div id="tracking-status" class="status-inactive">Not Tracking</div>
      </div>
      
      <!-- File Info -->
      <div class="file-info">
        <div id="file-name">No file selected</div>
        <div id="page-name"></div>
      </div>
      
      <!-- Control Buttons -->
      <div class="control-buttons">
        <button id="start-button">Start Tracking</button>
        <button id="stop-button">Stop Tracking</button>
      </div>
      
      <!-- Files List -->
      <div class="files-list" id="files-list">
        <!-- Files will be added here dynamically -->
      </div>
    </div>
    
    <!-- Summary Tab -->
    <div id="summary-tab" class="tab-content">
      <div id="summary-loading"></div>
      <div id="summary-container">
        <!-- Summary data will be loaded here -->
      </div>
    </div>
    
    <!-- Settings Tab -->
    <div id="settings-tab" class="tab-content">
      <div class="settings-section">
        <div class="setting-item">
          <div class="setting-label">Background Tracking</div>
          <label class="switch">
            <input type="checkbox" id="background-tracking" checked>
            <span class="slider"></span>
          </label>
        </div>
        <p class="setting-description">
          When enabled, tracking continues even when switching between files.
        </p>
        
        <div class="setting-item">
          <div class="setting-label">Firebase Sync</div>
          <div>
            <button id="sync-to-firebase">Save to Firebase</button>
            <button id="sync-from-firebase">Load from Firebase</button>
            <span id="firebase-connection-status" class="firebase-indicator disconnected" title="Firebase disconnected"></span>
          </div>
        </div>
        
        <div id="firebase-status"></div>
        
        <!-- Storage Status Section -->
        <div class="setting-item storage-status-container">
          <div class="setting-label">Local Storage Status</div>
          <div id="storage-status-indicator" class="status-indicator"></div>
        </div>
        
        <div id="storage-info">
          <div id="storage-usage"></div>
          <div id="storage-actions">
            <button id="clear-storage" class="danger-button">Clear Local Storage</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<script>
    // Firebase variables
    let firebaseConfig = null;
    let firebaseInitialized = false;
    let firebaseApp = null;
    let firebaseDb = null;
    let userId = null;
    let files = {};
    let activeFileId = null;
    let activePage = null;
    let isTracking = false;
    let timerInterval = null;
    let startTime = null;
    let updateTimerInterval = null;
    let summaryLoaded = false;
    let activeFileName = null;
    let activePageName = null;
    let backgroundTracking = true;
    let summaryData = null;
    let lastSavedTimestamp = 0;
    let trackingData = {};
    let inMemoryCache = {}; // Fallback cache when localStorage fails
    let firebaseConnected = false;
    let connectionRef = null;

    // Initialize Firebase when config is received
    function initializeFirebase(config) {
      try {
        console.log('Initializing Firebase with config:', config);
        firebaseConfig = config;
        
        // Initialize Firebase app if not already initialized
        if (!firebase.apps.length) {
          firebaseApp = firebase.initializeApp(firebaseConfig);
        } else {
          firebaseApp = firebase.app();
        }
        
        firebaseDb = firebase.database();
        firebaseInitialized = true;
        
        // Monitor Firebase connection status
        setupFirebaseConnectionMonitor();
        
        // Enable Firebase persistence if possible
        try {
          firebase.database().goOnline();
          updateFirebaseConnectionStatus('connecting');
          console.log('Firebase connection online');
        } catch (persistError) {
          console.warn('Could not enable Firebase persistence:', persistError);
          updateFirebaseConnectionStatus('disconnected');
        }
        
        // Set up anonymous authentication
        firebase.auth().onAuthStateChanged((user) => {
          if (user) {
            console.log('Firebase auth state changed: user signed in', user.uid);
            // User is signed in
            userId = user.uid;
            
            // Store user ID to localStorage for persistence across restarts
            try {
              localStorage.setItem('figmaTimeTrackUserId', userId);
            } catch (e) {
              console.warn('Could not save user ID to localStorage:', e);
            }
            
            // Notify plugin that Firebase is initialized
            parent.postMessage({ pluginMessage: { type: 'firebase-init-complete', userId: userId } }, '*');
            
            // Set up real-time listener for tracking data
            setupFirebaseDataListener();
            
            // Immediately check if we need to start a new day's tracking
            checkAndHandleDayChange();
            
            // Immediately load summary data if available
            loadSummaryFromFirebase();
          } else {
            console.log('Firebase auth state changed: no user signed in');
            // User is signed out, sign in anonymously
            firebase.auth().signInAnonymously()
              .then(() => {
                console.log('Signed in anonymously to Firebase');
              })
              .catch((error) => {
                console.error('Error signing in anonymously:', error);
                handleFirebaseError(error);
              });
          }
        });
      } catch (error) {
        console.error('Error initializing Firebase:', error);
        handleFirebaseError(error);
      }
    }
    
    // Set up real-time listener for changes to Firebase data
    function setupFirebaseDataListener() {
      if (!firebaseDb || !userId) {
        console.warn('Firebase not initialized, cannot set up data listener');
        return;
      }
      
      try {
        console.log('Setting up Firebase real-time data listener');
        const dataRef = firebaseDb.ref('timeData/' + userId);
        
        // Detach any existing listeners
        dataRef.off();
        
        // Listen for value changes
        dataRef.on('value', (snapshot) => {
          const data = snapshot.val();
          if (data) {
            console.log('Real-time update from Firebase received');
            
            // Update in-memory data
            summaryData = data;
            lastSavedTimestamp = Date.now();
            
            // Try to store a backup in localStorage
            try {
              localStorage.setItem('figmaTimeTrackSummary_backup', JSON.stringify(summaryData));
            } catch (e) {
              console.warn('Could not save Firebase data to localStorage backup:', e);
            }
            
            // Update UI if on summary tab
            if (document.getElementById('summary-tab').classList.contains('active')) {
              updateSummaryDisplay(data);
            }
          }
        }, (error) => {
          console.error('Firebase real-time listener error:', error);
          handleFirebaseError(error);
        });
        
      } catch (error) {
        console.error('Error setting up Firebase data listener:', error);
      }
    }
    
    // Handle Firebase errors gracefully
    function handleFirebaseError(error) {
      console.error('Firebase error:', error);
      
      // Update connection status
      updateFirebaseConnectionStatus('disconnected');
      
      // Notify the plugin about the error
      parent.postMessage({ 
        pluginMessage: { 
          type: 'firebase-error', 
          error: error.message || 'Unknown Firebase error'
        } 
      }, '*');
      
      // Show error in UI
      document.getElementById('firebase-status').textContent = 'Firebase Error: ' + (error.message || 'Unknown error');
      document.getElementById('firebase-status').style.color = 'red';
      
      // If we're on the summary tab, use local data immediately
      if (document.getElementById('summary-tab').classList.contains('active')) {
        // First try to use any cached data
        if (summaryData && Object.keys(summaryData).length > 0) {
          console.log('Using cached summary data due to Firebase error');
          updateSummaryDisplay(summaryData);
        } else {
          // Otherwise request local data
          requestLocalSummaryData();
        }
      }
    }
    
    // Check if we need to start a new day's tracking (8am to 8am cycle)
    function checkAndHandleDayChange() {
      if (!firebaseDb || !userId) return;
      
      try {
        // Get the last reset timestamp
        const lastResetRef = firebaseDb.ref('users/' + userId + '/lastReset');
        lastResetRef.once('value')
          .then(snapshot => {
            const lastReset = snapshot.val() || 0;
            const now = new Date();
            const currentTime = now.getTime();
            
            // Check if it's past 8am
            const todayEightAM = new Date(now);
            todayEightAM.setHours(8, 0, 0, 0);
            
            // If it's before 8am, we use yesterday's 8am as reference
            if (now.getHours() < 8) {
              todayEightAM.setDate(todayEightAM.getDate() - 1);
            }
            
            // Check if we haven't reset since the last 8am mark
            if (lastReset < todayEightAM.getTime()) {
              console.log('Day change detected (8am-8am cycle). Archiving previous day data...');
              
              // Archive previous day's data first
              archivePreviousDayData(lastReset, todayEightAM.getTime())
                .then(() => {
                  // Update the last reset timestamp
                  lastResetRef.set(currentTime);
                  console.log('Day change handled, reset timestamp updated');
                })
                .catch(error => {
                  console.error('Error handling day change:', error);
                });
            } else {
              console.log('No day change needed. Last reset:', new Date(lastReset).toLocaleString());
            }
          })
          .catch(error => {
            console.error('Error checking day change:', error);
          });
      } catch (error) {
        console.error('Error in checkAndHandleDayChange:', error);
      }
    }

    // Archive previous day's data for history
    function archivePreviousDayData(lastReset, currentReset) {
      return new Promise((resolve, reject) => {
        try {
          console.log('Archiving data from', new Date(lastReset).toLocaleString(), 'to', new Date(currentReset).toLocaleString());
          
          // Get the current data
          const currentDataRef = firebaseDb.ref('timeData/' + userId);
          currentDataRef.once('value')
            .then(snapshot => {
              const currentData = snapshot.val();
              
              if (!currentData) {
                console.log('No data to archive');
                resolve();
                return;
              }
              
              // Create an archive entry with timestamp
              const archiveRef = firebaseDb.ref('timeDataArchive/' + userId + '/' + currentReset);
              
              // Store the current data in the archive
              archiveRef.set({
                periodStart: lastReset || (currentReset - 86400000), // Default to 24 hours before if no last reset
                periodEnd: currentReset,
                data: currentData
              })
                .then(() => {
                  console.log('Previous day data archived successfully');
                  // We don't clear the data - we keep accumulating
                  resolve();
                })
                .catch(error => {
                  console.error('Error archiving data:', error);
                  reject(error);
                });
            })
            .catch(error => {
              console.error('Error getting current data for archiving:', error);
              reject(error);
            });
        } catch (error) {
          console.error('Error in archivePreviousDayData:', error);
          reject(error);
        }
      });
    }

    // Check if summary tab is active and load data if needed
    function checkSummaryTabAndLoadData() {
      // If summary tab is active and data hasn't been loaded yet
      if (document.getElementById('summary-tab').classList.contains('active')) {
        console.log('Summary tab is active, checking for data');
        
        // First try to use localStorage data if available
        const savedData = loadSummaryFromLocalStorage();
        if (savedData && Object.keys(savedData).length > 0) {
          console.log('Using saved data from localStorage for tab activation');
          summaryData = savedData;
          updateSummaryDisplay(savedData);
        }
        // Then if we have in-memory data, use that
        else if (summaryData && Object.keys(summaryData).length > 0) {
          console.log('Using existing in-memory data for tab activation');
          updateSummaryDisplay(summaryData);
        }
        // Otherwise request fresh data
        else {
          console.log('No data found, requesting fresh data');
          requestLocalSummaryData();
        }
      }
    }

    // Save data to Firebase
    function saveToFirebase(data, userId) {
      if (!firebaseInitialized) {
        console.error('Firebase not initialized yet, cannot save data');
        return;
      }
      
      try {
        console.log('Saving data to Firebase for user:', userId);
        const dbRef = firebase.database().ref('users/' + userId + '/files');
        
        // Use set to completely replace the data
        dbRef.set(data)
          .then(() => {
            console.log('Data saved to Firebase successfully');
            document.getElementById('firebase-status').textContent = 'Data synced to Firebase';
            document.getElementById('firebase-status').style.color = 'green';
            
            // Clear status message after 3 seconds
            setTimeout(() => {
              document.getElementById('firebase-status').textContent = '';
            }, 3000);
          })
          .catch((error) => {
            console.error('Error saving data to Firebase:', error);
            handleFirebaseError(error);
          });
      } catch (error) {
        console.error('Error in saveToFirebase:', error);
        handleFirebaseError(error);
      }
    }

    // Load data from Firebase
    function loadFromFirebase(userId, retryWithLocal = true) {
      if (!firebaseInitialized) {
        console.error('Firebase not initialized yet, cannot load data');
        
        if (retryWithLocal) {
          console.log('Loading summary from local data instead');
          loadSummaryFromLocal();
        }
        return;
      }
      
      try {
        console.log('Loading data from Firebase for user:', userId);
        document.getElementById('summary-loading').textContent = 'Loading data from Firebase...';
        
        const dbRef = firebase.database().ref('users/' + userId + '/files');
        
        dbRef.once('value')
          .then((snapshot) => {
            const data = snapshot.val();
            
            if (data) {
              console.log('Data loaded from Firebase:', data);
              
              // Send data to plugin
              parent.postMessage({ 
                pluginMessage: { 
                  type: 'firebase-data-loaded',
                  data: data
                } 
              }, '*');
              
              // Update UI with data
              updateSummaryDisplay(data);
              summaryLoaded = true;
              
              document.getElementById('firebase-status').textContent = 'Data loaded from Firebase';
              document.getElementById('firebase-status').style.color = 'green';
              
              // Clear status message after 3 seconds
              setTimeout(() => {
                document.getElementById('firebase-status').textContent = '';
              }, 3000);
            } else {
              console.log('No data found in Firebase');
              
              if (retryWithLocal) {
                console.log('Loading summary from local data instead');
                loadSummaryFromLocal();
              }
              
              // Notify plugin no data was found
              parent.postMessage({ 
                pluginMessage: { 
                  type: 'firebase-data-loaded',
                  data: {}
                } 
              }, '*');
            }
          })
          .catch((error) => {
            console.error('Error loading data from Firebase:', error);
            handleFirebaseError(error);
            
            if (retryWithLocal) {
              console.log('Loading summary from local data instead');
              loadSummaryFromLocal();
            }
          });
      } catch (error) {
        console.error('Error in loadFromFirebase:', error);
        handleFirebaseError(error);
        
        if (retryWithLocal) {
          console.log('Loading summary from local data instead');
          loadSummaryFromLocal();
        }
      }
    }

    // Load summary from local data
    function loadSummaryFromLocal() {
      console.log('Requesting local summary data');
      document.getElementById('summary-loading').textContent = 'Loading from local data...';
      
      // Request summary data from plugin
      parent.postMessage({ pluginMessage: { 
        type: 'get-summary',
        immediate: true
      } }, '*');
    }

    // Update file info display
    function updateFileInfo(fileName, pageName) {
      console.log('Updating file info:', { fileName, pageName });
      
      // Update file name display
      const fileNameElement = document.getElementById('file-name');
      if (fileNameElement) {
        fileNameElement.textContent = fileName || 'Not selected';
      }
      
      // Update page name display
      const pageNameElement = document.getElementById('page-name');
      if (pageNameElement) {
        pageNameElement.textContent = pageName || 'Not selected';
      }
    }
    
    // Format time in HH:MM:SS
    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Format time for display (converts to hours, minutes, seconds)
    function formatTimeDisplay(seconds) {
      if (seconds < 60) {
        return `${seconds}s`;
      } else if (seconds < 3600) {
        const minutes = Math.floor(seconds / 60);
        return `${minutes}m`;
      } else {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${minutes}m`;
      }
    }
    
    // Update timer display based on tracking status
    function updateTimerDisplay(tracking, startTime) {
      console.log('Updating timer display:', { tracking, startTime });
      
      isTracking = tracking;
      
      // Clear any existing timer interval
      if (updateTimerInterval) {
        clearInterval(updateTimerInterval);
        updateTimerInterval = null;
      }
      
      if (tracking && startTime) {
        // Store tracking start time
        trackingStartTime = startTime;
        
        // Start updating the timer every second
        updateTimerInterval = setInterval(() => {
          const now = Date.now();
          const elapsed = now - trackingStartTime;
          const seconds = Math.floor(elapsed / 1000);
          document.getElementById('timer').textContent = formatTime(seconds);
        }, 1000);
        
        // Update initial time
        const initialElapsed = Date.now() - startTime;
        const initialSeconds = Math.floor(initialElapsed / 1000);
        document.getElementById('timer').textContent = formatTime(initialSeconds);
        
        // Show the timer dot as active
        document.getElementById('timer-dot').style.display = 'block';
        
        // Update status text
        document.getElementById('status-text').textContent = 'Currently tracking';
        document.getElementById('status-text').className = 'status-active';
        
        // Update button visibility
        document.getElementById('toggle-timer').style.display = 'none';
        document.getElementById('save-time').style.display = 'inline-block';
      } else {
        // Reset the timer display
        document.getElementById('timer').textContent = '00:00:00';
        
        // Hide the timer dot
        document.getElementById('timer-dot').style.display = 'none';
        
        // Update status text
        document.getElementById('status-text').textContent = 'Not tracking';
        document.getElementById('status-text').className = '';
        
        // Update button visibility
        document.getElementById('toggle-timer').style.display = 'inline-block';
        document.getElementById('save-time').style.display = 'none';
      }
    }
    
    // Update the file list display with unified view across all files
    function updateFileList(files, currentActiveFileId) {
      const filesContainer = document.getElementById('files-container');
      filesContainer.innerHTML = '';
      
      // Store all files for future reference
      allFiles = files || [];
      
      // Update the active file ID
      if (currentActiveFileId) {
        activeFileId = currentActiveFileId;
      }
      
      console.log('Updating file list:', { 
        filesCount: allFiles.length, 
        activeFileId: activeFileId 
      });
      
      if (!allFiles || allFiles.length === 0) {
        filesContainer.innerHTML = '<div>No files tracked yet</div>';
        return;
      }
      
      // Add a summary header
      const summaryHeader = document.createElement('div');
      summaryHeader.className = 'summary-title';
      summaryHeader.textContent = 'Time Summary (All Files)';
      filesContainer.appendChild(summaryHeader);
      
      // Sort files with active file first, then by total time (most time first)
      const sortedFiles = [...allFiles].sort((a, b) => {
        // Active file always first
        if (a.id === activeFileId) return -1;
        if (b.id === activeFileId) return 1;
        
        // Then by total time
        return b.totalTime - a.totalTime;
      });
      
      // Calculate total time across all files
      const totalTimeAllFiles = sortedFiles.reduce((total, file) => total + file.totalTime, 0);
      
      // Add total time summary
      if (totalTimeAllFiles > 0) {
        const totalTimeElement = document.createElement('div');
        totalTimeElement.className = 'total-time-summary';
        totalTimeElement.innerHTML = `
          <div class="total-label">Total Time Tracked:</div>
          <div class="total-value">${formatTime(Math.floor(totalTimeAllFiles / 1000))}</div>
        `;
        filesContainer.appendChild(totalTimeElement);
      }
      
      // Create file cards
      sortedFiles.forEach(file => {
        const isCurrentlyActive = file.id === activeFileId;
        
        const fileCard = document.createElement('div');
        fileCard.className = `file-card ${isCurrentlyActive ? 'active' : ''}`;
        
        const fileHeader = document.createElement('div');
        fileHeader.className = 'file-header';
        
        const fileName = document.createElement('div');
        fileName.className = 'file-name';
        
        // Add indicator for active file
        if (isCurrentlyActive) {
          const activeIndicator = document.createElement('span');
          activeIndicator.className = 'active-indicator';
          fileName.appendChild(activeIndicator);
        }
        
        const fileNameText = document.createElement('span');
        fileNameText.textContent = file.name;
        fileName.appendChild(fileNameText);
        
        const fileTime = document.createElement('div');
        fileTime.className = 'file-time';
        fileTime.textContent = formatTime(Math.floor(file.totalTime / 1000));
        
        fileHeader.appendChild(fileName);
        fileHeader.appendChild(fileTime);
        fileCard.appendChild(fileHeader);
        
        // Create page list if it has pages
        if (file.pages && Object.keys(file.pages).length > 0) {
          const pagesList = document.createElement('div');
          pagesList.className = 'pages-list';
          
          // Convert pages object to array and sort by tracked time
          const pagesArray = Object.values(file.pages);
          const sortedPages = [...pagesArray].sort((a, b) => {
            // Active page always first
            if (a.id === activePageId) return -1;
            if (b.id === activePageId) return 1;
            
            // Then by tracked time
            return b.totalTime - a.totalTime;
          });
          
          let hasPages = false;
          sortedPages.forEach(page => {
            // Skip pages with no tracked time unless they're active
            if (page.totalTime === 0 && page.id !== activePageId) return;
            hasPages = true;
            
            const pageRow = document.createElement('div');
            pageRow.className = `page-row ${page.id === activePageId ? 'active' : ''}`;
            
            const pageName = document.createElement('div');
            pageName.className = 'page-name';
            
            // Add indicator for active page
            if (page.id === activePageId) {
              const activeIndicator = document.createElement('span');
              activeIndicator.textContent = '• ';
              activeIndicator.style.color = '#18a0fb';
              pageName.appendChild(activeIndicator);
            }
            
            const pageNameText = document.createElement('span');
            pageNameText.textContent = page.name;
            pageName.appendChild(pageNameText);
            
            const pageTime = document.createElement('div');
            pageTime.className = 'page-time';
            pageTime.textContent = formatTime(Math.floor(page.totalTime / 1000));
            
            pageRow.appendChild(pageName);
            pageRow.appendChild(pageTime);
            pagesList.appendChild(pageRow);
          });
          
          if (hasPages) {
            fileCard.appendChild(pagesList);
          }
        }
        
        filesContainer.appendChild(fileCard);
      });
    }
    
    // Update the UI when we receive all files data
    function handleAllFilesData(data) {
      if (!data.files) return;
      
      // Update the file list with all files data
      updateFileList(data.files, data.activeFileId);
      
      // Update any other UI elements that need all files data
      updateTotalTimeDisplay(data.files);
    }

    // Calculate and display total time across all files
    function updateTotalTimeDisplay(files) {
      if (!files || !files.length) return;
      
      // Calculate total time
      const totalSeconds = files.reduce((total, file) => {
        return total + Math.floor(file.totalTime / 1000);
      }, 0);
      
      // Update total time display if it exists
      const totalTimeElement = document.querySelector('.total-time-display');
      if (totalTimeElement) {
        totalTimeElement.textContent = formatTime(totalSeconds);
      }
    }

    // Update summary display with better file name handling and time tracking
    function updateSummaryDisplay(filesData) {
      try {
        console.log('Updating summary display with data:', 
                    filesData ? (typeof filesData === 'object' ? 
                                Object.keys(filesData).length + ' files' : 
                                typeof filesData) : 
                    'no data');
        
        // Get the summary container
        const summaryContainer = document.getElementById('summary-container');
        
        // Clear previous content
        summaryContainer.innerHTML = '';
        
        // Hide loading message
        document.getElementById('summary-loading').textContent = '';
        
        // Check if we have data
        if (!filesData || Object.keys(filesData).length === 0) {
          console.log('No files data available for summary');
          summaryContainer.innerHTML = '<p class="no-data">No tracking data available yet</p>';
          
          // Add a refresh button
          const refreshButton = document.createElement('button');
          refreshButton.textContent = 'Refresh Summary';
          refreshButton.className = 'summary-refresh-button';
          refreshButton.onclick = () => {
            console.log('Manual summary refresh requested');
            document.getElementById('summary-loading').textContent = 'Refreshing summary...';
            parent.postMessage({ pluginMessage: { type: 'get-summary', immediate: true } }, '*');
          };
          summaryContainer.appendChild(refreshButton);
          
          return;
        }
        
        // Create summary header
        const header = document.createElement('div');
        header.className = 'summary-header';
        header.innerHTML = `
          <div class="summary-title">Summary (8am-8am Cycle)</div>
          <div class="summary-refresh">
            <button id="refresh-summary">Refresh</button>
          </div>
        `;
        summaryContainer.appendChild(header);
        
        // Add refresh functionality
        document.getElementById('refresh-summary').addEventListener('click', () => {
          console.log('Manual summary refresh requested');
          document.getElementById('summary-loading').textContent = 'Refreshing summary...';
          parent.postMessage({ pluginMessage: { type: 'get-summary', immediate: true } }, '*');
        });
        
        // Create summary list
        const summaryList = document.createElement('div');
        summaryList.className = 'summary-list';
        
        // Track total time across all files
        let totalSeconds = 0;
        
        // Debug the data structure if needed
        console.log('Processing files data:', 
                   typeof filesData === 'object' ? 
                   'Object with ' + Object.keys(filesData).length + ' keys' : 
                   typeof filesData);
        
        // Sort files by time spent (descending) for better display
        const fileEntries = [];
        
        // Process each file and collect valid entries
        Object.keys(filesData).forEach((fileId) => {
          try {
            const file = filesData[fileId];
            
            // Skip invalid data
            if (!file) {
              console.log('Skipping undefined file data for ID:', fileId);
              return;
            }
            
            // Debug the file data structure
            console.log('Processing file:', fileId, 
                       'name:', file.name || 'unnamed', 
                       'totalSeconds:', file.totalSeconds || 'none',
                       'totalTime:', file.totalTime || 'none');
            
            // Get the file time (handle different formats)
            let fileSeconds = 0;
            
            if (typeof file.totalSeconds === 'number') {
              fileSeconds = file.totalSeconds;
            } else if (typeof file.totalTime === 'number') {
              fileSeconds = Math.floor(file.totalTime / 1000);
            } else if (file.time && typeof file.time === 'number') {
              fileSeconds = Math.floor(file.time / 1000);
            } else if (file.duration && typeof file.duration === 'number') {
              fileSeconds = Math.floor(file.duration / 1000);
            }
            
            // Skip files with no time tracked
            if (fileSeconds <= 0) {
              console.log('Skipping file with no time:', file.name || fileId);
              return;
            }
            
            // Get the clean file name
            let fileName = file.name || file.fileName || fileId;
            
            // Remove path if present
            if (fileName.includes('/')) {
              fileName = fileName.split('/').pop();
            }
            
            // Remove .fig extension if present
            if (fileName.endsWith('.fig')) {
              fileName = fileName.substring(0, fileName.length - 4);
            }
            
            // Add to entries array for sorting
            fileEntries.push({
              id: fileId,
              name: fileName,
              seconds: fileSeconds
            });
            
            // Add to total
            totalSeconds += fileSeconds;
          } catch (fileError) {
            console.error('Error processing file in summary:', fileError);
          }
        });
        
        // Sort by time spent (descending)
        fileEntries.sort((a, b) => b.seconds - a.seconds);
        
        // Add entries to the list
        fileEntries.forEach(entry => {
          // Format the time
          const hours = Math.floor(entry.seconds / 3600);
          const minutes = Math.floor((entry.seconds % 3600) / 60);
          const seconds = Math.floor(entry.seconds % 60);
          
          const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          
          // Create file entry
          const fileEntry = document.createElement('div');
          fileEntry.className = 'summary-file-entry';
          
          // Set the content
          fileEntry.innerHTML = `
            <div class="summary-file-name">${entry.name || 'Unnamed File'}</div>
            <div class="summary-file-time">${formattedTime}</div>
          `;
          
          // Add the entry to the list
          summaryList.appendChild(fileEntry);
        });
        
        // Add the list to the container
        summaryContainer.appendChild(summaryList);
        
        // Add total time
        const totalTimeElement = document.createElement('div');
        totalTimeElement.className = 'summary-total';
        
        // Format total time
        const totalHours = Math.floor(totalSeconds / 3600);
        const totalMinutes = Math.floor((totalSeconds % 3600) / 60);
        const totalSecs = Math.floor(totalSeconds % 60);
        
        const formattedTotal = `${totalHours.toString().padStart(2, '0')}:${totalMinutes.toString().padStart(2, '0')}:${totalSecs.toString().padStart(2, '0')}`;
        
        totalTimeElement.innerHTML = `
          <div class="summary-total-label">Total Time:</div>
          <div class="summary-total-time">${formattedTotal}</div>
        `;
        
        summaryContainer.appendChild(totalTimeElement);
        
        // Store the summary data for persistence
        if (Object.keys(filesData).length > 0) {
          summaryData = filesData;
          saveSummaryToLocalStorage(filesData);
        }
        
        console.log('Summary display updated successfully. Total time:', formattedTotal);
        
      } catch (error) {
        console.error('Error updating summary display:', error);
        
        // Show error in the summary container
        const summaryContainer = document.getElementById('summary-container');
        summaryContainer.innerHTML = `<p class="error">Error displaying summary: ${error.message}</p>`;
        
        // Add a retry button
        const retryButton = document.createElement('button');
        retryButton.textContent = 'Retry';
        retryButton.className = 'summary-retry-button';
        retryButton.onclick = () => {
          // Try to load from localStorage first
          const savedData = loadSummaryFromLocalStorage();
          if (savedData) {
            console.log('Using saved data from localStorage after error');
            updateSummaryDisplay(savedData);
          } else {
            // If no localStorage data, request from plugin
            parent.postMessage({ pluginMessage: { type: 'get-summary', immediate: true } }, '*');
          }
        };
        summaryContainer.appendChild(retryButton);
      }
    }

    // Show error message
    function showErrorMessage(message) {
      const errorContainer = document.getElementById('error-container');
      errorContainer.textContent = message;
      errorContainer.style.display = 'block';
      
      // Hide after 5 seconds
      setTimeout(() => {
        errorContainer.style.display = 'none';
      }, 5000);
    }
    
    // Listen for messages from the plugin
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      console.log('Message received from plugin:', message.type);
      
      // Handle different message types
      
      // Firebase config handler
      if (message.type === 'firebase-config') {
        console.log('Received Firebase config');
        
        // Store user ID
        if (message.userId) {
          userId = message.userId;
          console.log('User ID set:', userId);
          
          // Store user ID in localStorage for persistence
          localStorage.setItem('figmaTimeTrackUserId', userId);
        }
        
        // Initialize Firebase with the config
        initializeFirebase(message.config);
      }
      
      // Handle tracking status
      else if (message.type === 'tracking-status') {
        console.log('Received tracking status:', message.isTracking);
        
        // Update tracking variables
        isTracking = message.isTracking;
        activeFileName = message.fileName;
        activePageName = message.pageName;
        backgroundTracking = message.backgroundTracking;
        
        // Update UI elements
        updateTrackingUI();
        updateTimerDisplay();
        updateBackgroundTrackingUI();
        
        // Display active file/page names
        updateFileInfo();
      }
      
      // Track file changes
      else if (message.type === 'file-changed') {
        console.log('File changed notification received');
        
        // Update active file and page
        activeFileId = message.fileId;
        activePage = message.pageId;
        activeFileName = message.fileName;
        activePageName = message.pageName;
        
        // Update file name in UI
        updateFileInfo();
        
        // If resetTimer flag is present, ensure the timer is reset
        if (message.resetTimer) {
          console.log('Resetting timer display due to file change');
          resetTimerDisplay();
        }
      }
      
      // Handle tracking update
      else if (message.type === 'tracking-update' || message.type === 'update-tracking') {
        console.log('Received tracking update:', message.file ? message.file.name : 'no file', 
                    'time:', message.time || 'unknown');
        
        // Store the tracking data for the current file
        if (message.file && message.time) {
          // Update the in-memory tracking data
          if (!trackingData) trackingData = {};
          
          const fileId = message.file.id || message.file.key || message.file.name;
          if (!fileId) {
            console.warn('Tracking update missing file ID');
            return;
          }
          
          // Create or update the file entry
          if (!trackingData[fileId]) {
            trackingData[fileId] = {
              id: fileId,
              name: message.file.name,
              totalTime: 0,
              lastUpdated: Date.now()
            };
          }
          
          // Update the time (convert to seconds if needed)
          let timeInSeconds = 0;
          if (typeof message.time === 'number') {
            if (message.time > 10000) {
              // Assume it's in milliseconds
              timeInSeconds = Math.floor(message.time / 1000);
            } else {
              // Assume it's already in seconds
              timeInSeconds = message.time;
            }
          }
          
          // Update the tracking data
          trackingData[fileId].totalTime += timeInSeconds * 1000; // Store as milliseconds
          trackingData[fileId].totalSeconds = Math.floor(trackingData[fileId].totalTime / 1000);
          trackingData[fileId].lastUpdated = Date.now();
          
          console.log('Updated tracking data for file:', trackingData[fileId].name, 
                      'total time:', formatTime(trackingData[fileId].totalSeconds));
          
          // First, try to save to Firebase (preferred storage)
          if (firebaseInitialized && firebaseDb && userId) {
            saveRecentUpdateToFirebase(fileId, trackingData[fileId]);
          }
          
          // Also save to localStorage as backup
          const saveSuccess = saveSummaryToLocalStorage(trackingData);
          
          // If localStorage fails, keep data in memory
          if (!saveSuccess) {
            console.log('Saving to in-memory cache due to localStorage failure');
            inMemoryCache = { ...trackingData };
          }
          
          // Update summary if on summary tab
          if (document.getElementById('summary-tab').classList.contains('active')) {
            updateSummaryDisplay(trackingData);
          }
        }
      }
      
      // Handle update-summary message
      else if (message.type === 'update-summary') {
        console.log('Received summary update', message.immediate ? '(immediate)' : '');
        
        // Store the data for persistence
        if (message.files) {
          console.log('Received files data from plugin:', 
                     message.files ? 
                     (typeof message.files === 'object' ? Object.keys(message.files).length + ' files' : typeof message.files) 
                     : 'no data');
          
          // Make sure it's a valid object
          if (typeof message.files === 'object' && message.files !== null) {
            // Store data in memory
            summaryData = message.files;
            lastSavedTimestamp = Date.now();
            
            // Save to localStorage for persistence
            const saved = saveSummaryToLocalStorage(message.files);
            if (!saved) {
              console.warn('Failed to save to localStorage - using in-memory cache');
              inMemoryCache = { ...message.files };
            }
            
            // Update the display
            updateSummaryDisplay(message.files);
          } else {
            console.error('Invalid files data received:', message.files);
            
            // Try to use previously stored data
            if (summaryData) {
              console.log('Using previously stored in-memory data');
              updateSummaryDisplay(summaryData);
            } else {
              // Try to load from localStorage as a last resort
              const savedData = loadSummaryFromLocalStorage();
              if (savedData) {
                console.log('Using localStorage data due to invalid received data');
                summaryData = savedData;
                updateSummaryDisplay(savedData);
              } else {
                // No data available
                document.getElementById('summary-container').innerHTML = 
                  '<p class="no-data">No tracking data available</p>';
              }
            }
          }
        } else {
          console.log('No files data received in update-summary message');
          
          // Try to use previously stored data
          if (summaryData) {
            console.log('Using previously stored in-memory data');
            updateSummaryDisplay(summaryData);
          } else {
            // Try to load from localStorage as a last resort
            const savedData = loadSummaryFromLocalStorage();
            if (savedData) {
              console.log('Using localStorage data due to missing received data');
              summaryData = savedData;
              updateSummaryDisplay(savedData);
            } else {
              // No data available
              document.getElementById('summary-container').innerHTML = 
                '<p class="no-data">No tracking data available</p>';
            }
          }
        }
        
        // Hide loading message
        document.getElementById('summary-loading').textContent = '';
      }
      
      else if (message.type === 'save-to-firebase') {
        console.log('Saving data to Firebase');
        
        // Save data to Firebase
        saveToFirebase(message.files, message.userId);
      } 
      
      else if (message.type === 'load-from-firebase') {
        console.log('Loading data from Firebase');
        
        // Load data from Firebase
        loadFromFirebase(message.userId);
      }
    };

    // Reset the timer display
    function resetTimerDisplay() {
      // Clear any existing interval
      if (updateTimerInterval) {
        clearInterval(updateTimerInterval);
        updateTimerInterval = null;
      }
      
      // Reset timer text
      document.getElementById('timer').textContent = '00:00:00';
      
      // Hide timer dot since we're no longer tracking
      document.getElementById('timer-dot').style.display = 'none';
      
      // Update button visibility
      document.getElementById('start-button').style.display = 'block';
      document.getElementById('stop-button').style.display = 'none';
      
      console.log('Timer display reset');
    }

    // Update the timer display
    function updateTimerDisplay() {
      // Clear any existing timer interval
      if (updateTimerInterval) {
        clearInterval(updateTimerInterval);
        updateTimerInterval = null;
      }
      
      // Get the timer element
      const timerElement = document.getElementById('timer');
      
      if (isTracking) {
        console.log('Updating timer for active tracking');
        
        // Show the timer dot to indicate active tracking
        document.getElementById('timer-dot').style.display = 'inline-block';
        
        // Show the appropriate buttons
        document.getElementById('stop-button').style.display = 'block';
        document.getElementById('start-button').style.display = 'none';
        
        // Set the start time if it's not already set
        if (!startTime) {
          startTime = Date.now();
        }
        
        // Update timer immediately
        updateTimerText();
        
        // Set up interval to update timer
        updateTimerInterval = setInterval(updateTimerText, 1000);
      } else {
        console.log('Updating timer for inactive state');
        
        // Hide the timer dot since we're not tracking
        document.getElementById('timer-dot').style.display = 'none';
        
        // Show the appropriate buttons
        document.getElementById('start-button').style.display = 'block';
        document.getElementById('stop-button').style.display = 'none';
        
        // Reset the timer display
        timerElement.textContent = '00:00:00';
        startTime = null;
      }
    }

    // Update the timer text
    function updateTimerText() {
      if (!isTracking || !startTime) return;
      
      const now = Date.now();
      const elapsed = now - startTime;
      
      // Format the time as HH:MM:SS
      const seconds = Math.floor(elapsed / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      
      const formattedHours = hours.toString().padStart(2, '0');
      const formattedMinutes = (minutes % 60).toString().padStart(2, '0');
      const formattedSeconds = (seconds % 60).toString().padStart(2, '0');
      
      // Update the timer text
      document.getElementById('timer').textContent = 
        `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
    }

    // Update the file information display
    function updateFileInfo() {
      // Update file and page name displays
      document.getElementById('file-name').textContent = activeFileName || 'No file';
      document.getElementById('page-name').textContent = activePageName || 'No page';
    }

    // Update tracking UI
    function updateTrackingUI() {
      // Update the tracking status text
      const statusElement = document.getElementById('tracking-status');
      statusElement.textContent = isTracking ? 'Tracking' : 'Not Tracking';
      statusElement.className = isTracking ? 'status-active' : 'status-inactive';
    }

    // Update background tracking UI
    function updateBackgroundTrackingUI() {
      // Update the background tracking toggle
      document.getElementById('background-tracking').checked = backgroundTracking;
    }

    // Update the file list display
    function updateFilesList() {
      // Implementation of updateFilesList function
    }

    // Initialization function for the UI (keep this minimal and focused)
    function initializeUI() {
      console.log('Initializing UI');
      
      // Try to restore user ID from localStorage
      const savedUserId = localStorage.getItem('figmaTimeTrackUserId');
      if (savedUserId) {
        console.log('Restored user ID from localStorage:', savedUserId);
        userId = savedUserId;
      }
      
      // Try to restore summary data from localStorage
      try {
        const savedSummary = localStorage.getItem('figmaTimeTrackSummary');
        const savedTimestamp = localStorage.getItem('figmaTimeTrackSummaryTimestamp');
        
        if (savedSummary) {
          console.log('Found saved summary in localStorage from:', 
                     savedTimestamp ? new Date(parseInt(savedTimestamp)).toLocaleString() : 'unknown');
          
          summaryData = JSON.parse(savedSummary);
          if (savedTimestamp) {
            lastSavedTimestamp = parseInt(savedTimestamp);
          }
        } else {
          console.log('No saved summary found in localStorage');
        }
      } catch (error) {
        console.error('Error restoring from localStorage:', error);
      }
      
      // Check storage status
      checkStorageStatus();
    }

    // Run initialization when page loads
    window.onload = function() {
      console.log('Page loaded - initializing UI');
      
      // Initialize UI components
      initializeUI();
      
      // Request immediate summary data (with a slight delay to ensure UI is ready)
      setTimeout(() => {
        parent.postMessage({ pluginMessage: { type: 'get-summary', immediate: true } }, '*');
      }, 500);
      
      // Notify plugin that UI is loaded
      parent.postMessage({ pluginMessage: { type: 'ui-loaded' } }, '*');
      
      // Set the default tab or reactivate tabs (if already loaded with a cached state)
      console.log('Activating first tab directly...');
      const activeTab = document.querySelector('.tab-button.active');
      
      // If there's an active tab already, keep it active
      if (activeTab) {
        const tabId = activeTab.getAttribute('data-tab');
        console.log('Using already active tab:', tabId);
        const tabContent = document.getElementById(tabId);
        if (tabContent) {
          tabContent.classList.add('active');
        }
        
        // If it's the summary tab, load summary data
        if (tabId === 'summary-tab') {
          // Load summary data from localStorage or memory
          if (summaryData) {
            console.log('Using existing summary data on load');
            updateSummaryDisplay(summaryData);
          } else {
            const savedData = loadSummaryFromLocalStorage();
            if (savedData) {
              console.log('Using localStorage data on load');
              summaryData = savedData;
              updateSummaryDisplay(savedData);
            }
          }
        }
      } 
      // Otherwise activate the first tab
      else {
        const firstTab = document.querySelector('.tab-button');
        if (firstTab) {
          firstTab.click(); // This will trigger the click handler set up in DOMContentLoaded
        }
      }
    };

    // Handle visibility changes
    document.addEventListener('visibilitychange', () => {
      const isVisible = !document.hidden;
      console.log('Visibility changed:', isVisible ? 'visible' : 'hidden');
      
      // Notify plugin of visibility change
      parent.postMessage({ 
        pluginMessage: { 
          type: 'ui-visibility-changed', 
          isVisible: isVisible 
        } 
      }, '*');
      
      // Refresh data if becoming visible and on summary tab
      if (isVisible && document.getElementById('summary-tab').classList.contains('active')) {
        console.log('Refreshing data on visibility change');
        requestSummaryRefresh();
      }
    });

    // Request a summary refresh
    function requestSummaryRefresh() {
      console.log('Requesting summary refresh');
      document.getElementById('summary-loading').textContent = 'Refreshing summary...';
      parent.postMessage({ pluginMessage: { type: 'get-summary', immediate: true } }, '*');
    }

    // Save summary data to localStorage with better error handling
    function saveSummaryToLocalStorage(data) {
      try {
        if (!data) {
          console.warn('Attempted to save null or undefined data to localStorage');
          return false;
        }
        
        if (typeof data !== 'object') {
          console.warn('Attempted to save non-object data to localStorage:', typeof data);
          return false;
        }
        
        // Check if data is empty
        if (Object.keys(data).length === 0) {
          console.log('No data to save to localStorage (empty object)');
          return false;
        }
        
        // Try to reduce data size before saving
        const compressedData = compressDataForStorage(data);
        
        // First try normal storage
        try {
          const jsonString = JSON.stringify(compressedData);
          
          // If the data is small enough, store it normally
          if (jsonString.length < 250000) {
            console.log(`Saving summary data to localStorage (${jsonString.length} chars, ${Object.keys(compressedData).length} files)`);
            localStorage.setItem('figmaTimeTrackSummary', jsonString);
            localStorage.setItem('figmaTimeTrackSummaryTimestamp', Date.now().toString());
            
            // Clear any chunked data since we're storing in one piece
            clearChunkedData();
            
            console.log('Summary data saved successfully');
            return true;
          } else {
            // Data is too large, use chunking
            console.log(`Data too large for single localStorage item (${jsonString.length} chars), using chunks`);
            return saveDataInChunks(compressedData);
          }
        } catch (storageError) {
          // Check if it's a quota error
          if (isQuotaError(storageError)) {
            console.warn('localStorage quota exceeded, trying chunking approach');
            
            // Try chunking with more aggressive compression 
            const minimalData = compressDataForStorage(data, true);
            return saveDataInChunks(minimalData); 
          } else {
            console.error('Error saving to localStorage:', storageError);
            return false;
          }
        }
      } catch (error) {
        console.error('Unexpected error in saveSummaryToLocalStorage:', error);
        return false;
      }
    }
    
    // Check if an error is a quota error
    function isQuotaError(error) {
      return (
        error.name === 'QuotaExceededError' || 
        error.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
        // Safari private mode has a different error
        error.code === 22 ||
        error.code === 1014 ||
        // Check message for other browsers
        error.message && (
          error.message.includes('quota') || 
          error.message.includes('storage') || 
          error.message.includes('limit')
        )
      );
    }
    
    // Save data in chunks to work around localStorage limits
    function saveDataInChunks(data) {
      try {
        // Clear any existing chunks
        clearChunkedData();
        
        // Serialize the data
        const jsonString = JSON.stringify(data);
        
        // Determine chunk size (50KB per chunk is safe)
        const chunkSize = 50000;
        const chunks = Math.ceil(jsonString.length / chunkSize);
        
        console.log(`Splitting data into ${chunks} chunks of ${chunkSize} chars each`);
        
        // Store metadata first
        localStorage.setItem('figmaTimeTrackSummary_meta', JSON.stringify({
          chunks: chunks,
          totalLength: jsonString.length,
          timestamp: Date.now()
        }));
        
        // Store each chunk
        for (let i = 0; i < chunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, jsonString.length);
          const chunk = jsonString.substring(start, end);
          
          localStorage.setItem(`figmaTimeTrackSummary_chunk_${i}`, chunk);
          console.log(`Saved chunk ${i+1}/${chunks}, length: ${chunk.length}`);
        }
        
        localStorage.setItem('figmaTimeTrackSummaryTimestamp', Date.now().toString());
        console.log(`Successfully saved data in ${chunks} chunks`);
        return true;
      } catch (error) {
        console.error('Error saving data in chunks:', error);
        
        // Try with even more minimal data - just keep top 3 files as last resort
        try {
          const emergencyData = {};
          const topFiles = Object.entries(data)
            .sort((a, b) => getFileTime(b[1]) - getFileTime(a[1]))
            .slice(0, 3);
          
          topFiles.forEach(([fileId, fileData]) => {
            emergencyData[fileId] = {
              id: fileId,
              name: fileData.name,
              totalSeconds: getFileTime(fileData)
            };
          });
          
          console.log('Trying emergency storage with just top 3 files');
          localStorage.setItem('figmaTimeTrackSummary_emergency', JSON.stringify(emergencyData));
          localStorage.setItem('figmaTimeTrackSummaryTimestamp', Date.now().toString());
          return true;
        } catch (emergencyError) {
          console.error('Even emergency storage failed:', emergencyError);
          return false;
        }
      }
    }
    
    // Clear chunked data from localStorage
    function clearChunkedData() {
      try {
        // Get metadata if it exists
        const metaString = localStorage.getItem('figmaTimeTrackSummary_meta');
        if (metaString) {
          const meta = JSON.parse(metaString);
          const chunks = meta.chunks || 0;
          
          // Remove each chunk
          for (let i = 0; i < chunks; i++) {
            localStorage.removeItem(`figmaTimeTrackSummary_chunk_${i}`);
          }
          
          // Remove metadata
          localStorage.removeItem('figmaTimeTrackSummary_meta');
          console.log(`Cleared ${chunks} data chunks from localStorage`);
        }
      } catch (error) {
        console.error('Error clearing chunked data:', error);
      }
    }
    
    // Compress data for localStorage to avoid quota issues
    function compressDataForStorage(data, aggressive = false) {
      // Clone the data to avoid modifying the original
      const result = {};
      
      // Determine how many files to keep
      const maxFiles = aggressive ? 5 : 20;
      
      // Get most recent/important files
      const fileEntries = Object.entries(data)
        .filter(([_, fileData]) => fileData && typeof fileData === 'object')
        .sort((a, b) => {
          // Sort by lastUpdated (if available) or by totalTime (most time first)
          const aTime = a[1].lastUpdated || 0;
          const bTime = b[1].lastUpdated || 0;
          
          if (aTime !== bTime) return bTime - aTime;
          
          const aTotalTime = getFileTime(a[1]);
          const bTotalTime = getFileTime(b[1]);
          return bTotalTime - aTotalTime;
        })
        .slice(0, maxFiles);
      
      // Add selected files to result with minimal data
      fileEntries.forEach(([fileId, fileData]) => {
        // Keep only essential data
        result[fileId] = {
          id: fileId,
          name: fileData.name,
          totalTime: getFileTime(fileData) * 1000,
          totalSeconds: getFileTime(fileData)
        };
      });
      
      return result;
    }
    
    // Helper to get file time from various formats
    function getFileTime(fileData) {
      if (!fileData) return 0;
      
      if (typeof fileData.totalSeconds === 'number') {
        return fileData.totalSeconds;
      } else if (typeof fileData.totalTime === 'number') {
        return Math.floor(fileData.totalTime / 1000);
      } else if (fileData.time && typeof fileData.time === 'number') {
        return Math.floor(fileData.time / 1000);
      } else if (fileData.duration && typeof fileData.duration === 'number') {
        return Math.floor(fileData.duration / 1000);
      }
      
      return 0;
    }

    // Load summary data from localStorage with better error handling
    function loadSummaryFromLocalStorage() {
      try {
        console.log('Attempting to load summary data from localStorage');
        
        // First check if we have chunked data
        const metaString = localStorage.getItem('figmaTimeTrackSummary_meta');
        if (metaString) {
          return loadChunkedData();
        }
        
        // Check for emergency data if no chunks
        const emergencyData = localStorage.getItem('figmaTimeTrackSummary_emergency');
        if (emergencyData) {
          console.log('Loading emergency data from localStorage');
          try {
            return JSON.parse(emergencyData);
          } catch (parseError) {
            console.error('Error parsing emergency data:', parseError);
          }
        }
        
        // Try normal storage if no chunks or emergency data
        const savedData = localStorage.getItem('figmaTimeTrackSummary');
        if (!savedData) {
          console.log('No summary data found in localStorage');
          return null;
        }
        
        // Safely parse the JSON data
        try {
          const parsedData = JSON.parse(savedData);
          console.log('Successfully loaded summary data from localStorage', 
                      Object.keys(parsedData).length, 'files');
          return parsedData;
        } catch (parseError) {
          console.error('Error parsing localStorage data:', parseError);
          // If data is corrupt, remove it
          localStorage.removeItem('figmaTimeTrackSummary');
          localStorage.removeItem('figmaTimeTrackSummaryTimestamp');
          return null;
        }
      } catch (error) {
        console.error('Error accessing localStorage:', error);
        return null;
      }
    }
    
    // Load data that was saved in chunks
    function loadChunkedData() {
      try {
        console.log('Loading chunked data from localStorage');
        
        // Get metadata
        const metaString = localStorage.getItem('figmaTimeTrackSummary_meta');
        if (!metaString) {
          console.warn('No chunk metadata found in localStorage');
          return null;
        }
        
        const meta = JSON.parse(metaString);
        const chunks = meta.chunks || 0;
        
        if (chunks <= 0) {
          console.warn('Invalid chunk count in metadata');
          return null;
        }
        
        // Reconstruct the data from chunks
        let jsonString = '';
        let missingChunks = 0;
        
        for (let i = 0; i < chunks; i++) {
          const chunk = localStorage.getItem(`figmaTimeTrackSummary_chunk_${i}`);
          if (chunk) {
            jsonString += chunk;
          } else {
            console.warn(`Missing chunk ${i} when loading data`);
            missingChunks++;
          }
        }
        
        if (missingChunks > 0) {
          console.warn(`${missingChunks} chunks were missing out of ${chunks} total chunks`);
          if (missingChunks === chunks) {
            console.error('All chunks are missing, cannot load data');
            return null;
          }
        }
        
        // Verify the length
        if (jsonString.length !== meta.totalLength) {
          console.warn(`Reconstructed data length (${jsonString.length}) doesn't match expected length (${meta.totalLength})`);
        }
        
        // Parse the reconstructed string
        const parsedData = JSON.parse(jsonString);
        console.log(`Successfully loaded data from ${chunks} chunks`, 
                    Object.keys(parsedData).length, 'files');
        return parsedData;
      } catch (error) {
        console.error('Error loading chunked data:', error);
        
        // Try emergency data as backup
        try {
          const emergencyData = localStorage.getItem('figmaTimeTrackSummary_emergency');
          if (emergencyData) {
            console.log('Falling back to emergency data');
            return JSON.parse(emergencyData);
          }
        } catch (emergencyError) {
          console.error('Error loading emergency data:', emergencyError);
        }
        
        return null;
      }
    }

    // Add function to request local summary data from the plugin
    function requestLocalSummaryData() {
      console.log('Requesting summary data from plugin');
      document.getElementById('summary-loading').textContent = 'Loading summary data...';
      
      // Request summary data from plugin
      parent.postMessage({ 
        pluginMessage: { 
          type: 'get-summary',
          immediate: true
        }
      }, '*');
    }

    // Add debugging for summary display issues
    function logSummaryDebug(message, data) {
      const debugElement = document.getElementById('summary-debug');
      if (debugElement) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const debugMsg = `[${timestamp}] ${message}`;
        
        let debugContent = debugElement.textContent || '';
        if (debugContent) debugContent += '\n';
        
        if (data) {
          const dataStr = typeof data === 'object' 
            ? JSON.stringify(data, null, 2) 
            : data.toString();
          debugContent += `${debugMsg}\n${dataStr}`;
        } else {
          debugContent += debugMsg;
        }
        
        // Limit debug length
        if (debugContent.length > 2000) {
          debugContent = debugContent.substring(debugContent.length - 2000);
        }
        
        debugElement.textContent = debugContent;
      }
    }

    // Check if summary tab is active and needs immediate data
    function checkSummaryTabAndLoadData() {
      // Check if summary tab is active
      const summaryTab = document.querySelector('.tab-button[data-tab="summary"]');
      const isSummaryActive = summaryTab && summaryTab.classList.contains('active');
      
      if (isSummaryActive) {
        console.log('Summary tab is active, requesting immediate data');
        // Generate summary from local data immediately
        requestLocalSummaryData();
      }
    }

    // Load summary data from Firebase with better error handling and timeout
    function loadSummaryFromFirebase() {
      if (!firebaseInitialized || !firebaseDb || !userId) {
        console.warn('Firebase not initialized, using backup data');
        return useBackupData();
      }
      
      try {
        console.log('Loading summary data from Firebase');
        document.getElementById('summary-loading').textContent = 'Loading from Firebase...';
        
        // Set a timeout for the Firebase operation
        let timeoutId = setTimeout(() => {
          console.warn('Firebase load timed out, using backup data');
          useBackupData();
        }, 5000);
        
        // Get data from Firebase
        firebaseDb.ref('timeData/' + userId).once('value')
          .then(snapshot => {
            // Clear the timeout since we got a response
            clearTimeout(timeoutId);
            
            const data = snapshot.val();
            console.log('Data loaded from Firebase:', data ? 'has data' : 'empty');
            
            if (data) {
              // Store in memory
              summaryData = data;
              
              // Save backup to localStorage
              try {
                localStorage.setItem('figmaTimeTrackSummary_backup', JSON.stringify(data));
              } catch (e) {
                console.warn('Could not save Firebase data to localStorage backup:', e);
              }
              
              // Update the display
              updateSummaryDisplay(data);
            } else {
              console.log('No data in Firebase, checking backup');
              useBackupData();
            }
          })
          .catch(error => {
            // Clear the timeout since we got an error response
            clearTimeout(timeoutId);
            
            console.error('Error loading from Firebase:', error);
            handleFirebaseError(error);
            useBackupData();
          });
      } catch (error) {
        console.error('Error in loadSummaryFromFirebase:', error);
        useBackupData();
      }
    }

    // Use backup data from memory, localStorage or empty state
    function useBackupData() {
      console.log('Using backup data sources');
      
      // First try in-memory data
      if (summaryData && Object.keys(summaryData).length > 0) {
        console.log('Using in-memory data');
        updateSummaryDisplay(summaryData);
        return true;
      }
      
      // Then try in-memory cache
      if (inMemoryCache && Object.keys(inMemoryCache).length > 0) {
        console.log('Using in-memory cache');
        updateSummaryDisplay(inMemoryCache);
        return true;
      }
      
      // Then try Firebase backup in localStorage
      try {
        const firebaseBackup = localStorage.getItem('figmaTimeTrackSummary_backup');
        if (firebaseBackup) {
          const parsedBackup = JSON.parse(firebaseBackup);
          console.log('Using Firebase backup from localStorage');
          summaryData = parsedBackup;
          updateSummaryDisplay(parsedBackup);
          return true;
        }
      } catch (e) {
        console.warn('Error loading Firebase backup from localStorage:', e);
      }
      
      // Then try chunked/regular localStorage data
      const localData = loadSummaryFromLocalStorage();
      if (localData && Object.keys(localData).length > 0) {
        console.log('Using localStorage data');
        summaryData = localData;
        updateSummaryDisplay(localData);
        return true;
      }
      
      // No data found
      console.log('No backup data found');
      document.getElementById('summary-container').innerHTML = 
        '<p class="no-data">No tracking data available</p>' +
        '<button class="summary-refresh-button" onclick="requestSummaryRefresh()">Refresh</button>';
      
      return false;
    }

    // Save data to Firebase
    function saveDataToFirebase(data, userId, timestamp) {
      try {
        if (!firebaseInitialized || !firebaseDb) {
          console.warn('Firebase not initialized, cannot save data');
          updateFirebaseStatus('Firebase not ready, save failed', true);
          return;
        }
        
        console.log('Saving data to Firebase for user', userId);
        updateFirebaseStatus('Saving to Firebase...');
        
        // Store in the timeData path with userId as the key
        const timeDataRef = firebaseDb.ref('timeData/' + userId);
        
        timeDataRef.set(data)
          .then(() => {
            console.log('Data saved to Firebase successfully');
            // Store the data in our local variable
            summaryData = data;
            updateFirebaseStatus('Data saved to Firebase');
          })
          .catch(error => {
            console.error('Error saving to Firebase:', error);
            updateFirebaseStatus('Firebase save error: ' + error.message, true);
          });
          
        // Also save last sync timestamp
        const syncRef = firebaseDb.ref('lastSync/' + userId);
        syncRef.set(timestamp);
      } catch (error) {
        console.error('Error in saveDataToFirebase:', error);
        updateFirebaseStatus('Firebase error: ' + error.message, true);
      }
    }

    // Update Firebase status display
    function updateFirebaseStatus(message, isError = false) {
      const statusElement = document.getElementById('firebase-status');
      if (statusElement) {
        statusElement.textContent = message;
        statusElement.style.color = isError ? 'red' : 'green';
        
        // Clear status after some time if it's not an error
        if (!isError) {
          setTimeout(() => {
            statusElement.textContent = '';
          }, 5000);
        }
      }
    }

    // Set up tabs functionality
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded - setting up tab buttons');
      
      // Get tab buttons and add click listeners
      const tabButtons = document.querySelectorAll('.tab-button');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', function() {
          const tabId = this.getAttribute('data-tab');
          console.log('Tab clicked:', tabId);
          
          // Remove active class from all buttons and contents
          document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
          });
          
          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });
          
          // Add active class to clicked button and corresponding content
          this.classList.add('active');
          
          const content = document.getElementById(tabId);
          if (content) {
            content.classList.add('active');
            
            // Special handling for summary tab
            if (tabId === 'summary-tab') {
              console.log('Summary tab activated');
              document.getElementById('summary-loading').textContent = 'Loading summary...';
              
              // Use stored data immediately if available
              if (summaryData) {
                console.log('Using stored summary data for immediate display');
                updateSummaryDisplay(summaryData);
              } else {
                // Try loading from localStorage
                const savedData = loadSummaryFromLocalStorage();
                if (savedData) {
                  console.log('Using localStorage data for immediate display');
                  summaryData = savedData;
                  updateSummaryDisplay(savedData);
                }
              }
              
              // Request fresh data
              setTimeout(() => {
                requestSummaryRefresh();
              }, 200);
            }
          }
        });
      });
      
      // Set up other button event listeners
      
      // Start button
      document.getElementById('start-button').addEventListener('click', function() {
        parent.postMessage({ pluginMessage: { type: 'start-tracking' } }, '*');
      });
      
      // Stop button
      document.getElementById('stop-button').addEventListener('click', function() {
        parent.postMessage({ pluginMessage: { type: 'stop-tracking' } }, '*');
      });
      
      // Background tracking toggle
      document.getElementById('background-tracking').addEventListener('change', function(e) {
        const enabled = e.target.checked;
        console.log('Background tracking toggled:', enabled);
        parent.postMessage({ 
          pluginMessage: { 
            type: 'toggle-background-tracking', 
            enabled: enabled 
          }
        }, '*');
      });
      
      // Firebase sync buttons
      document.getElementById('sync-to-firebase').addEventListener('click', function() {
        console.log('Manual sync to Firebase requested');
        parent.postMessage({ pluginMessage: { type: 'sync-to-firebase' } }, '*');
      });
      
      document.getElementById('sync-from-firebase').addEventListener('click', function() {
        console.log('Manual sync from Firebase requested');
        parent.postMessage({ pluginMessage: { type: 'sync-from-firebase' } }, '*');
      });
    });

    // Show storage warning
    function showStorageWarning() {
      // Only show once per session
      if (localStorage.getItem('storageWarningShown')) {
        return;
      }
      
      // Create the warning element if it doesn't exist
      let warningElement = document.getElementById('storage-warning');
      if (!warningElement) {
        warningElement = document.createElement('div');
        warningElement.id = 'storage-warning';
        warningElement.className = 'warning-message';
        warningElement.innerHTML = `
          <div class="message-title">Storage Limitation</div>
          <p>Your browser's storage is approaching its limit. The plugin will keep your most recent 
          tracking data, but older entries may not be saved locally.</p>
          <div class="message-action">
            <button id="dismiss-storage-warning">Dismiss</button>
          </div>
        `;
        
        // Add to the top of the active tab
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
          activeTab.insertBefore(warningElement, activeTab.firstChild);
          
          // Add dismiss button handler
          document.getElementById('dismiss-storage-warning').addEventListener('click', function() {
            warningElement.style.display = 'none';
            localStorage.setItem('storageWarningShown', 'true');
          });
        }
      }
    }

    // Check localStorage status and update UI
    function checkStorageStatus() {
      try {
        // Display container
        document.getElementById('storage-status-indicator').className = 'status-indicator';
        
        // Test localStorage availability
        const testKey = 'figmaTimeTrack_storageTest';
        
        try {
          localStorage.setItem(testKey, '1');
          localStorage.removeItem(testKey);
          
          // Check how much is used
          let totalSize = 0;
          let trackerSize = 0;
          
          // Estimate current usage
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            const value = localStorage.getItem(key);
            const size = (key.length + value.length) * 2; // Unicode is 2 bytes per char
            
            totalSize += size;
            
            if (key.startsWith('figmaTimeTrack')) {
              trackerSize += size;
            }
          }
          
          // Check how much is used by our app
          const usagePercent = Math.min(100, Math.round((trackerSize / 5000000) * 100)); // Assumes 5MB limit
          
          // Update the indicator
          const statusIndicator = document.getElementById('storage-status-indicator');
          const storageUsage = document.getElementById('storage-usage');
          
          if (usagePercent < 50) {
            statusIndicator.className = 'status-indicator good';
            storageUsage.innerHTML = `Storage usage: ${formatStorageSize(trackerSize)} (${usagePercent}% of limit)`;
            storageUsage.style.color = '#34c759';
          } else if (usagePercent < 80) {
            statusIndicator.className = 'status-indicator warning';
            storageUsage.innerHTML = `Storage usage: ${formatStorageSize(trackerSize)} (${usagePercent}% of limit)`;
            storageUsage.style.color = '#ffcc00';
          } else {
            statusIndicator.className = 'status-indicator error';
            storageUsage.innerHTML = `Storage usage: ${formatStorageSize(trackerSize)} (${usagePercent}% of limit)<br>Your data may not fully save. Consider clearing storage.`;
            storageUsage.style.color = '#ff3b30';
          }
          
          // Set up clear storage button
          document.getElementById('clear-storage').addEventListener('click', function() {
            if (confirm('Are you sure you want to clear all locally stored data? This cannot be undone.')) {
              clearAllLocalStorage();
              checkStorageStatus();
            }
          });
          
        } catch (error) {
          // localStorage is not available
          document.getElementById('storage-status-indicator').className = 'status-indicator error';
          document.getElementById('storage-usage').innerHTML = 'Error: Local storage is not available on this browser';
          document.getElementById('storage-usage').style.color = '#ff3b30';
          console.error('localStorage is not available:', error);
        }
      } catch (error) {
        console.error('Error checking storage status:', error);
      }
    }
    
    // Format storage size for display
    function formatStorageSize(bytes) {
      if (bytes < 1024) {
        return bytes + ' bytes';
      } else if (bytes < 1024 * 1024) {
        return (bytes / 1024).toFixed(1) + ' KB';
      } else {
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }
    }
    
    // Clear all localStorage related to this app
    function clearAllLocalStorage() {
      try {
        // First clear chunks
        clearChunkedData();
        
        // Clear any other storage
        const keysToRemove = [];
        
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('figmaTimeTrack')) {
            keysToRemove.push(key);
          }
        }
        
        // Remove all keys
        keysToRemove.forEach(key => {
          localStorage.removeItem(key);
        });
        
        console.log(`Cleared ${keysToRemove.length} items from localStorage`);
        
        // Reset summaryData
        summaryData = null;
        inMemoryCache = {};
        
        // Update UI
        const storageUsage = document.getElementById('storage-usage');
        storageUsage.innerHTML = 'Storage cleared successfully';
        storageUsage.style.color = '#34c759';
        
        // Show a message to the user
        alert('Local storage has been cleared successfully.');
      } catch (error) {
        console.error('Error clearing localStorage:', error);
      }
    }

    // Save just the most recent update to Firebase (more efficient)
    function saveRecentUpdateToFirebase(fileId, fileData) {
      if (!firebaseInitialized || !firebaseDb || !userId) {
        console.warn('Firebase not ready, cannot save recent update');
        return false;
      }
      
      try {
        console.log('Saving update for file to Firebase:', fileData.name);
        
        // Get the reference to just this file's data
        const fileRef = firebaseDb.ref('timeData/' + userId + '/' + fileId);
        
        // Set the data for this file
        fileRef.update(fileData)
          .then(() => {
            console.log('File update saved to Firebase successfully');
            updateFirebaseStatus('Data synced to Firebase');
            
            // Also update the last sync timestamp
            firebaseDb.ref('lastSync/' + userId).set(Date.now());
          })
          .catch((error) => {
            console.error('Error saving file update to Firebase:', error);
            handleFirebaseError(error);
            return false;
          });
          
        return true;
      } catch (error) {
        console.error('Error in saveRecentUpdateToFirebase:', error);
        return false;
      }
    }

    // Auto-save to Firebase every few minutes if there are changes
    let lastAutoSaveTimestamp = 0;
    setInterval(() => {
      // Only auto-save if we have Firebase initialized and data has changed
      if (firebaseInitialized && firebaseDb && userId && trackingData && Object.keys(trackingData).length > 0) {
        const now = Date.now();
        
        // Check if it's been at least 2 minutes since last auto-save
        if (now - lastAutoSaveTimestamp > 2 * 60 * 1000) {
          console.log('Auto-saving data to Firebase');
          
          // Save all tracking data to Firebase
          const timeDataRef = firebaseDb.ref('timeData/' + userId);
          timeDataRef.update(trackingData)
            .then(() => {
              console.log('Auto-save to Firebase successful');
              lastAutoSaveTimestamp = now;
            })
            .catch(error => {
              console.error('Auto-save to Firebase failed:', error);
            });
        }
      }
    }, 60 * 1000); // Check every minute, but only save every 2+ minutes

    // Monitor Firebase connection status
    function setupFirebaseConnectionMonitor() {
      if (!firebaseDb) return;
      
      try {
        // Get the connection reference
        connectionRef = firebaseDb.ref('.info/connected');
        
        // Listen for connection changes
        connectionRef.on('value', (snap) => {
          firebaseConnected = snap.val() === true;
          
          if (firebaseConnected) {
            console.log('Firebase connection established');
            updateFirebaseConnectionStatus('connected');
          } else {
            console.log('Firebase disconnected');
            updateFirebaseConnectionStatus('disconnected');
          }
        });
        
        // Set up a heartbeat to keep connection alive
        setupFirebaseHeartbeat();
        
      } catch (error) {
        console.error('Error setting up connection monitor:', error);
        updateFirebaseConnectionStatus('disconnected');
      }
    }
    
    // Set up a heartbeat to keep Firebase connection alive
    function setupFirebaseHeartbeat() {
      if (!firebaseDb || !userId) return;
      
      try {
        // Create a heartbeat reference
        const heartbeatRef = firebaseDb.ref('heartbeats/' + userId);
        
        // Send a heartbeat every minute
        setInterval(() => {
          if (firebaseConnected && firebaseDb) {
            heartbeatRef.set({
              timestamp: firebase.database.ServerValue.TIMESTAMP,
              client: 'figma-plugin'
            }).catch(error => {
              console.warn('Heartbeat error:', error);
            });
          }
        }, 60 * 1000); // Every minute
        
      } catch (error) {
        console.error('Error setting up heartbeat:', error);
      }
    }
    
    // Update Firebase connection status indicator
    function updateFirebaseConnectionStatus(status) {
      const indicator = document.getElementById('firebase-connection-status');
      if (!indicator) return;
      
      // Remove all classes first
      indicator.classList.remove('connected', 'connecting', 'disconnected');
      
      // Add appropriate class
      indicator.classList.add(status);
      
      // Update tooltip
      if (status === 'connected') {
        indicator.title = 'Firebase connected';
      } else if (status === 'connecting') {
        indicator.title = 'Connecting to Firebase...';
      } else {
        indicator.title = 'Firebase disconnected';
      }
    }
</script>
</body>
</html>

